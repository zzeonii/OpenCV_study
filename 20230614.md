# 스레드 (thread)
### qt_06_thread.py
```python
import sys
from PySide2.QtWidgets import *
from PySide2.QtCore import *

class Worker(QThread):

    def run(self):
        while True:
            print("안녕하세요")
            self.sleep(1) # 초단위

class MainWindow(QWidget):
    def __init__(self, parent=None):
        QWidget.__init__(self, parent)

        self.woker = Worker()
        self.woker.start()

if __name__ == '__main__':

    
    app = QApplication(sys.argv)

    window = MainWindow()
    window.show()
    
    app.exec_() 
```
![image](https://github.com/zzeonii/OpenCV_study/assets/129237950/930c0d09-fe99-4dee-a7cb-ef075c41536d)

### qt_07_thread_signal.py
```python
import sys
from PySide2.QtWidgets import *
from PySide2.QtCore import *

class Worker(QThread):

    # timeout = pyqtSignal(int) # PyQt5, QtCore 안에 정의
    timeout = Signal(int) # PySide2, QtCore 안에 정의


    def __init__(self):
        super().__init__()
        self.num = 0

    def run(self):
        while True:

            # 방출, 값을 전달, 내보내기
            # 해당 시그널(signal)에 연결된(connect) 함수가 잇다면 해당 함수에 값을 전달해서 호출
            self.timeout.emit(self.num)
            self.num += 1
            self.sleep(1)

class MainWindow(QWidget):

    def __init__(self, parent=None):
        QWidget.__init__(self, parent)

        self.worker = Worker()
        self.worker.start()
        self.worker.timeout.connect(self.timeout)

        self.edit = QLineEdit(self)
        self.edit.setReadOnly(True)
        self.edit.move(10,10)

    @Slot(int)
    def timeout(self, num):
        self.edit.setText(str(num))



if __name__ == '__main__':
    app = QApplication(sys.argv)

    window = MainWindow()
    window.show()

    app.exec_()
```
![image](https://github.com/zzeonii/OpenCV_study/assets/129237950/b0eb0b4a-b98b-4f16-8b13-ed8e56b35b0d)
![image](https://github.com/zzeonii/OpenCV_study/assets/129237950/4a1a44b2-e952-4a69-a67d-0ca5b11c0c4f)


# 알고리즘
## 정렬 알고리즘
- 원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거
- 단순 : 삽입 정렬, 선택 정렬
    - 낮은 부하로 작은 데이터에 효율
    - 성능 제약이 있을 때 사용하기 좋음
    - 선택정렬은 쓰기 성능에 제약이 있을 때 우위
- 효율 : 합병 정렬, 힙 정렬, 퀵 정렬, 셀 정렬 등등
    - 구현이 복잡하지만 큰 데이터에 사용하기에 효율적
    - 복잡한 알고리즘의 비용으로 성능의 문제를 해결

### 선택 정렬(Selection Sort)
- 제자리 정렬 알고리즘의 하나
- 주어진 리스트 중에 최소값을 찾는다
- 그 값을 맨 앞에 위치한 값과 교체
- 맨 처음 위치를 빼고 나머지를 반복
- 시간복잡도 O(n2), 메모리가 제한적인 경우에 이점

### 거품 정렬, 버블 정렬(Bubble Sort)
- 인접한 두 원소를 검사하여 정렬
- 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환
- n 회전 후 큰 자료가 뒤에서 n번째로 이동
- n회전 시 이전 n-1의 마지막 위치는 제외
- 시간복잡도 O(n2)로 느린 편, 코드가 단순하기에 자주 사용

### 삽입 정렬(Insertion Sort)
- 제자리 정렬 알고리즘
- 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교, 자신의 위치를 찾아 삽입
- 배열이 길어질수록 효율이 떨어짐, 구현이 간단한 장점
- 시간 복잡도O(n2)지만, 선택이나 거품보다 빠름
